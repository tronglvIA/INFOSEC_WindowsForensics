WEBVTT

1
00:00:00.000 --> 00:00:04.155
We're covering course
8 of the file system.

2
00:00:04.155 --> 00:00:06.435
We are now in Module 3.

3
00:00:06.435 --> 00:00:07.740
In this module, we'll be

4
00:00:07.740 --> 00:00:10.545
talking about the root directory.

5
00:00:10.545 --> 00:00:13.350
The root directory is

6
00:00:13.350 --> 00:00:18.375
the highest directory level
of the volume structure.

7
00:00:18.375 --> 00:00:21.390
It contains a listing
of the files in

8
00:00:21.390 --> 00:00:25.530
directories located in
the root of the volume.

9
00:00:25.530 --> 00:00:28.035
It is structured in a series of

10
00:00:28.035 --> 00:00:30.795
32 byte directory entries,

11
00:00:30.795 --> 00:00:34.185
so two lines of 16.

12
00:00:34.185 --> 00:00:38.390
Each directory entry
is 32 bytes in length,

13
00:00:38.390 --> 00:00:40.310
may contains information about

14
00:00:40.310 --> 00:00:44.155
the files and folders
on the volume.

15
00:00:44.155 --> 00:00:46.280
The file system will read from

16
00:00:46.280 --> 00:00:48.605
the top of the directory down,

17
00:00:48.605 --> 00:00:51.320
and it stops when it
finds a directory entry

18
00:00:51.320 --> 00:00:55.615
beginning with hexadecimal 00.

19
00:00:55.615 --> 00:00:58.580
This is a look at what

20
00:00:58.580 --> 00:01:00.230
the root directory looks

21
00:01:00.230 --> 00:01:03.775
like when we do it
with our tools.

22
00:01:03.775 --> 00:01:06.900
We can see we have entries at

23
00:01:06.900 --> 00:01:13.075
the top and then we have
an entry starting with 00.

24
00:01:13.075 --> 00:01:16.005
Now, the system will
stop reading here.

25
00:01:16.005 --> 00:01:19.340
Your file system will stop
when it comes to these 00s.

26
00:01:19.340 --> 00:01:24.230
But be aware, it is possible
for data to be written

27
00:01:24.230 --> 00:01:29.600
in using a hex editor and
another tool beyond those 00s,

28
00:01:29.600 --> 00:01:33.385
and this data would be
hidden from the file system.

29
00:01:33.385 --> 00:01:37.430
There are three types of
root directory entries.

30
00:01:37.430 --> 00:01:40.280
We can see a volume name
entry and this would be

31
00:01:40.280 --> 00:01:43.025
a user created name
for the volume.

32
00:01:43.025 --> 00:01:47.670
This would always be the top
entry in the root directory.

33
00:01:47.670 --> 00:01:51.685
We also have what we call
short filenames entry.

34
00:01:51.685 --> 00:01:54.530
Every file and directory will

35
00:01:54.530 --> 00:01:58.479
have one of these short
filename entries.

36
00:01:58.479 --> 00:02:04.990
What short filename means is
it means that the name of

37
00:02:04.990 --> 00:02:12.760
the file conforms with that
8.3 naming convention,

38
00:02:12.760 --> 00:02:20.020
which means it has up to
eight uppercase characters,

39
00:02:20.020 --> 00:02:25.610
a dot, and then a
three-character file extension.

40
00:02:26.600 --> 00:02:30.100
If a file does not
conform to this,

41
00:02:30.100 --> 00:02:34.580
it will also have what we
call long filename entries.

42
00:02:34.580 --> 00:02:37.104
There'll be a short
filename alias,

43
00:02:37.104 --> 00:02:40.390
which will be six characters
of the file name,

44
00:02:40.390 --> 00:02:42.890
followed by a tilde, and

45
00:02:42.890 --> 00:02:45.095
then a three-character extension.

46
00:02:45.095 --> 00:02:47.810
But the full filename will be

47
00:02:47.810 --> 00:02:50.105
in the long filename entries,

48
00:02:50.105 --> 00:02:54.270
and these will be located
above the short filename.

49
00:02:54.670 --> 00:02:58.430
This is a look at a
volume directory entry.

50
00:02:58.430 --> 00:03:00.020
Remember, we said we had

51
00:03:00.020 --> 00:03:04.380
three types and this is the
look at a volume name entry.

52
00:03:04.550 --> 00:03:07.440
This would be the top entry in

53
00:03:07.440 --> 00:03:11.875
the directory if there was
a user-created volume name.

54
00:03:11.875 --> 00:03:15.610
We can see it begins
with the filename,

55
00:03:15.610 --> 00:03:19.090
which in our case is FAT 32.

56
00:03:19.640 --> 00:03:24.795
It also contains attributes

57
00:03:24.795 --> 00:03:29.625
such as read-only in system
volume or directory.

58
00:03:29.625 --> 00:03:35.330
It has also a modified
date and time.

59
00:03:35.330 --> 00:03:38.870
Because it is a volume
directory entry,

60
00:03:38.870 --> 00:03:42.175
it will only have
that one timestamp.

61
00:03:42.175 --> 00:03:44.810
When we look at a file entry,

62
00:03:44.810 --> 00:03:47.710
you will see three timestamps.

63
00:03:47.710 --> 00:03:52.050
The short filename entry,
just to reiterate,

64
00:03:52.050 --> 00:03:54.315
is eight uppercase characters

65
00:03:54.315 --> 00:03:57.560
and a three-character
file extension,

66
00:03:57.560 --> 00:04:03.580
and it is referred to as
8.3 or DOS-compliant.

67
00:04:03.580 --> 00:04:06.650
The long filename
happens when we mix

68
00:04:06.650 --> 00:04:09.275
cases where we have a filename

69
00:04:09.275 --> 00:04:11.630
that is longer than
eight characters or

70
00:04:11.630 --> 00:04:15.205
an extension longer
than three characters.

71
00:04:15.205 --> 00:04:17.300
This is what causes those long

72
00:04:17.300 --> 00:04:19.895
filename entries to be created.

73
00:04:19.895 --> 00:04:23.225
Here's a look at a
directory entry set.

74
00:04:23.225 --> 00:04:24.965
Down here at the bottom,

75
00:04:24.965 --> 00:04:28.310
we can see our short
filename entry.

76
00:04:28.310 --> 00:04:32.915
Every file and directory will
have one of these entries.

77
00:04:32.915 --> 00:04:37.084
We see the DOS alias,
that six character,

78
00:04:37.084 --> 00:04:39.575
all uppercase, a tilde,

79
00:04:39.575 --> 00:04:42.480
and then an extension.

80
00:04:43.460 --> 00:04:48.835
We also see above the
long filename entries.

81
00:04:48.835 --> 00:04:52.820
We're going to talk
about how we read

82
00:04:52.820 --> 00:04:57.010
these long filename entries
as we go through this course.

83
00:04:57.010 --> 00:05:00.960
But this is what a directory
entry set would look like.

84
00:05:00.960 --> 00:05:05.060
The short filename
entry, in this case,

85
00:05:05.060 --> 00:05:06.425
we have our filename,

86
00:05:06.425 --> 00:05:10.225
SHORT.TXT, and it was named.

87
00:05:10.225 --> 00:05:12.440
You can see this is not an alias,

88
00:05:12.440 --> 00:05:15.325
there's no tilde D if you
look over in the ASCII.

89
00:05:15.325 --> 00:05:18.140
This is the name of the
file and it would have

90
00:05:18.140 --> 00:05:21.760
no long filename
entries above it.

91
00:05:21.760 --> 00:05:25.030
It's all capital letters,

92
00:05:25.170 --> 00:05:27.970
up to eight characters,

93
00:05:27.970 --> 00:05:31.810
and then it has that
three-character TXT extension.

94
00:05:31.810 --> 00:05:33.580
You can see in here, we have

95
00:05:33.580 --> 00:05:36.010
the attributes and the attributes

96
00:05:36.010 --> 00:05:40.135
would be located at Offset
0B for a length of one byte.

97
00:05:40.135 --> 00:05:43.195
That's what we call
a packed byte.

98
00:05:43.195 --> 00:05:45.985
We break that out to binary,

99
00:05:45.985 --> 00:05:48.910
to see which flags were set.

100
00:05:48.910 --> 00:05:51.295
In other words, which
bits were turned on,

101
00:05:51.295 --> 00:05:55.705
and that would tell us which
attributes this file had.

102
00:05:55.705 --> 00:06:00.200
In our case, it just has
the archive bit set.

103
00:06:01.380 --> 00:06:05.635
Then we see at Offset 0D,

104
00:06:05.635 --> 00:06:09.580
the final time
millisecond refinement.

105
00:06:09.580 --> 00:06:13.900
This is just a millisecond
timestamp that we're going to

106
00:06:13.900 --> 00:06:18.745
add to our created
date and timestamp.

107
00:06:18.745 --> 00:06:21.640
It only refers to
the created date.

108
00:06:21.640 --> 00:06:25.405
Below that, and at Offset 0E,

109
00:06:25.405 --> 00:06:28.760
we see our created date and time.

110
00:06:29.610 --> 00:06:33.725
In this case, it's 6/25/2020 at

111
00:06:33.725 --> 00:06:41.275
1:13 PM and that is going to
be a length of four bytes.

112
00:06:41.275 --> 00:06:45.295
These two bytes at 0E
and 0F of the time,

113
00:06:45.295 --> 00:06:53.330
and at 01 and 02
would be our date.

114
00:06:53.400 --> 00:06:57.230
We have a last access date.

115
00:06:57.510 --> 00:07:00.895
Last Access just has a date.

116
00:07:00.895 --> 00:07:02.650
You can see that it's 02 and

117
00:07:02.650 --> 00:07:04.675
03 highlighted here in green.

118
00:07:04.675 --> 00:07:08.350
This is our last access date.

119
00:07:08.350 --> 00:07:11.090
There's no time with that.

120
00:07:11.160 --> 00:07:13.810
Next to that we have what we call

121
00:07:13.810 --> 00:07:16.045
our first cluster high word.

122
00:07:16.045 --> 00:07:18.430
In this case it's 00.

123
00:07:18.430 --> 00:07:21.280
The high word is
only used if we need

124
00:07:21.280 --> 00:07:24.310
more than two bytes to
address the cluster.

125
00:07:24.310 --> 00:07:26.695
In this case, we did not.

126
00:07:26.695 --> 00:07:30.775
Next, we have our
modified date and time.

127
00:07:30.775 --> 00:07:38.980
Again, the first two
bytes are 06 and 07,

128
00:07:38.980 --> 00:07:40.780
and these are the time.

129
00:07:40.780 --> 00:07:43.420
Then the next two bytes
would be the date.

130
00:07:43.420 --> 00:07:49.820
You can see those located
at offset 108 and 109.

131
00:07:51.680 --> 00:07:56.495
Next we have our first
cluster little word.

132
00:07:56.495 --> 00:07:59.710
Now, since we did not
have a high word,

133
00:07:59.710 --> 00:08:01.750
this two byte value

134
00:08:01.750 --> 00:08:04.810
represents the starting
cluster of this file.

135
00:08:04.810 --> 00:08:06.970
Then the last four bytes of

136
00:08:06.970 --> 00:08:11.270
the entry are the
file size in bytes.

137
00:08:11.490 --> 00:08:14.350
These are the possible
values we can

138
00:08:14.350 --> 00:08:16.870
have for that attribute byte.

139
00:08:16.870 --> 00:08:19.795
Remember, it's a one-byte value,

140
00:08:19.795 --> 00:08:22.180
and it's a packed byte.

141
00:08:22.180 --> 00:08:24.760
It gets broken out into binary,

142
00:08:24.760 --> 00:08:27.710
and we can see
which flags are up.

143
00:08:27.840 --> 00:08:31.585
It is possible to have
more than one attribute.

144
00:08:31.585 --> 00:08:34.915
You could have a
read-only system file.

145
00:08:34.915 --> 00:08:39.010
In which case should
have a hex value of 05.

146
00:08:39.010 --> 00:08:40.690
When you broke that out,

147
00:08:40.690 --> 00:08:44.480
you would see that those
two bits were set.

148
00:08:45.030 --> 00:08:49.810
The reserve byte off at 0C,

149
00:08:49.810 --> 00:08:53.215
is what we call a case indicator.

150
00:08:53.215 --> 00:08:58.540
Reserve byte, if it
is hexadecimal 1,0,

151
00:08:58.540 --> 00:09:01.750
that means this is
a short final day.

152
00:09:01.750 --> 00:09:05.530
It is 8.3 compliant file name.

153
00:09:05.530 --> 00:09:11.680
If at the reserve byte we
saw, a hexadecimal 00,

154
00:09:11.680 --> 00:09:14.800
that would indicate you're
looking at a long file name

155
00:09:14.800 --> 00:09:18.475
and it was not an 8.3
compliant filename.

156
00:09:18.475 --> 00:09:21.100
That's when we can identify

157
00:09:21.100 --> 00:09:24.295
a short filename from
a long filename.

158
00:09:24.295 --> 00:09:27.380
File time.

159
00:09:27.450 --> 00:09:30.670
FAT, 32 file time in

160
00:09:30.670 --> 00:09:34.300
all FAT file times are
going to be in local time,

161
00:09:34.300 --> 00:09:36.415
whatever time the
machine is set to.

162
00:09:36.415 --> 00:09:41.060
They're not recorded in
Universal Time, UTC.

163
00:09:42.330 --> 00:09:49.940
Here we see at offset 0E
and F are creation time.

164
00:09:50.160 --> 00:09:56.499
Down at offset 1,0 and 1,1,

165
00:09:56.499 --> 00:10:00.020
we see our creation date.

166
00:10:01.020 --> 00:10:08.630
They are read together
as a 32 bit value.

167
00:10:08.730 --> 00:10:12.430
This is how the value

168
00:10:12.430 --> 00:10:15.805
would be converted
into a date and time.

169
00:10:15.805 --> 00:10:19.030
Because if you just converted
this two-byte value,

170
00:10:19.030 --> 00:10:20.440
you're going to get a number,

171
00:10:20.440 --> 00:10:22.120
not a date time.

172
00:10:22.120 --> 00:10:24.760
But what happens is,

173
00:10:24.760 --> 00:10:29.050
your file system is
first going to convert

174
00:10:29.050 --> 00:10:33.920
those two bytes for time,
until little-endian.

175
00:10:33.920 --> 00:10:39.215
We saw in the previous
slide, it was AB69.

176
00:10:39.215 --> 00:10:41.500
Now this is converted
to little-endian,

177
00:10:41.500 --> 00:10:44.390
so we have 69AB.

178
00:10:44.460 --> 00:10:47.575
These bytes are separated.

179
00:10:47.575 --> 00:10:52.600
Then each nibble is separated.

180
00:10:52.600 --> 00:10:56.365
The six and the nine,
and the A and the B.

181
00:10:56.365 --> 00:10:59.470
Then each nibble is individually

182
00:10:59.470 --> 00:11:04.645
translated from hex
to a binary value.

183
00:11:04.645 --> 00:11:09.610
Remember, we converted from
hex to binary and decimal to

184
00:11:09.610 --> 00:11:12.040
binary back in one of

185
00:11:12.040 --> 00:11:15.580
our previous courses at the
beginning of this path.

186
00:11:15.580 --> 00:11:18.460
Once we get each binary value,

187
00:11:18.460 --> 00:11:22.720
we can then translate
the date and time.

188
00:11:22.720 --> 00:11:26.905
We are allowed five
bits for the seconds.

189
00:11:26.905 --> 00:11:29.380
We take the bits and
you can see here at

190
00:11:29.380 --> 00:11:32.245
the far right of the
screen outlined in yellow,

191
00:11:32.245 --> 00:11:35.140
these would be our
bits per seconds.

192
00:11:35.140 --> 00:11:39.924
We would fill them in
to the column values,

193
00:11:39.924 --> 00:11:42.040
and since we have five,

194
00:11:42.040 --> 00:11:45.925
we have column values from 1-16,

195
00:11:45.925 --> 00:11:49.195
1, 2, 4, 8, 16.

196
00:11:49.195 --> 00:11:53.770
Each column value increasing
by a power of two.

197
00:11:53.770 --> 00:11:56.005
We can see in our example,

198
00:11:56.005 --> 00:11:58.715
we have 11 seconds.

199
00:11:58.715 --> 00:12:01.545
We must multiply this by two,

200
00:12:01.545 --> 00:12:04.410
because we don't have enough bits

201
00:12:04.410 --> 00:12:07.645
here to account for 60 seconds.

202
00:12:07.645 --> 00:12:12.115
When we multiply 11
by 2, we get 22.

203
00:12:12.115 --> 00:12:14.755
Now we're going to
move to minutes.

204
00:12:14.755 --> 00:12:17.350
We have more bytes to
work within minutes.

205
00:12:17.350 --> 00:12:19.570
We're allowed six bytes.

206
00:12:19.570 --> 00:12:22.315
So we have column values from

207
00:12:22.315 --> 00:12:28.120
1-32 and you can see them in
the slide outlined in green.

208
00:12:28.120 --> 00:12:31.510
We take our binary values
that we converted from

209
00:12:31.510 --> 00:12:35.335
A and drop those down
into the column values.

210
00:12:35.335 --> 00:12:38.845
We can see we have 13 minutes.

211
00:12:38.845 --> 00:12:41.440
Then we would move on to hours.

212
00:12:41.440 --> 00:12:43.240
You can see hours at

213
00:12:43.240 --> 00:12:47.275
the left-hand side
here, outlined in red.

214
00:12:47.275 --> 00:12:50.980
We would have, again,

215
00:12:50.980 --> 00:12:54.640
five bytes toward the hour.

216
00:12:54.640 --> 00:12:59.270
We have column values from 1-16.

217
00:13:00.000 --> 00:13:06.670
We drop down our binary
conversion of our decimal number

218
00:13:06.670 --> 00:13:16.240
six into the columns and we
can see we end up with 13.

219
00:13:16.900 --> 00:13:22.605
Our time would be 13:13:22 PM.

220
00:13:22.605 --> 00:13:25.000
We could go back and add in

221
00:13:25.000 --> 00:13:28.490
our creation time
millisecond value.

222
00:13:28.950 --> 00:13:32.230
The FAT creation
date is translated

223
00:13:32.230 --> 00:13:34.975
in much the same way as
the FAT creation time.

224
00:13:34.975 --> 00:13:37.300
It is a little endian value,

225
00:13:37.300 --> 00:13:39.460
so we would have
to translate that.

226
00:13:39.460 --> 00:13:42.250
Original value was D950.

227
00:13:42.250 --> 00:13:47.365
We converge it here to little
endian and we have 50D9.

228
00:13:47.365 --> 00:13:50.750
Again, we break the bytes apart,

229
00:13:50.910 --> 00:13:54.760
50 and D9, and then
we split the nibbles,

230
00:13:54.760 --> 00:13:56.980
the 5, the 0,

231
00:13:56.980 --> 00:13:59.770
the D, and the 9.

232
00:13:59.770 --> 00:14:05.420
We convert each nibble
into its binary value.

233
00:14:06.900 --> 00:14:09.265
When we're translating this,

234
00:14:09.265 --> 00:14:15.955
we have five bits for the day.

235
00:14:15.955 --> 00:14:20.810
We have column values
one through 16.

236
00:14:21.030 --> 00:14:23.650
Our nibble was nine,

237
00:14:23.650 --> 00:14:27.370
so we would drop down our
column value nibbles into

238
00:14:27.370 --> 00:14:35.155
the correct column
values for nine.

239
00:14:35.155 --> 00:14:36.820
But we also have one of

240
00:14:36.820 --> 00:14:42.740
the D column values since
we're using five bytes.

241
00:14:43.710 --> 00:14:48.820
For months, we have
four bits to work with,

242
00:14:48.820 --> 00:14:51.130
and they are outlined in green.

243
00:14:51.130 --> 00:14:54.400
We take the next four bits
of our value and drop them

244
00:14:54.400 --> 00:14:58.070
down into the proper
column values.

245
00:14:59.910 --> 00:15:04.670
Our year is outlined in red.

246
00:15:06.300 --> 00:15:08.860
We take the remaining
bytes that we

247
00:15:08.860 --> 00:15:13.990
have and we would

248
00:15:13.990 --> 00:15:18.590
drop them down into their
proper column values.

249
00:15:20.550 --> 00:15:26.330
We have seven bits for the year.

250
00:15:26.450 --> 00:15:31.505
We come up with a
number of decimal 40.

251
00:15:31.505 --> 00:15:34.780
Now, the FAT file system uses

252
00:15:34.780 --> 00:15:39.115
an absolute date of
January 1st, 1980.

253
00:15:39.115 --> 00:15:43.180
So we would have
to add 1980 to 40,

254
00:15:43.180 --> 00:15:46.135
and we come up with 2020.

255
00:15:46.135 --> 00:15:50.440
For the months, we
come up with six,

256
00:15:50.440 --> 00:15:52.480
which would be the
sixth month and for

257
00:15:52.480 --> 00:15:54.790
the date we come up with 25.

258
00:15:54.790 --> 00:16:02.080
That makes our creation
date 25, June 2020.

259
00:16:02.080 --> 00:16:08.080
That brings us to our
last access date.

260
00:16:08.080 --> 00:16:10.630
This is translated the same

261
00:16:10.630 --> 00:16:13.555
way we do for the creation date.

262
00:16:13.555 --> 00:16:18.040
Last accessed only has
a date, not a time.

263
00:16:18.040 --> 00:16:20.645
You can see in the slide,

264
00:16:20.645 --> 00:16:23.070
you have D9 50.

265
00:16:23.070 --> 00:16:25.305
You must convert that
to little-endian,

266
00:16:25.305 --> 00:16:30.950
50 D9 and that gives us a date
of the 25th of June, 2020.

267
00:16:30.950 --> 00:16:34.520
We just converted that
in the previous slide.

268
00:16:34.980 --> 00:16:39.800
Now we're going to talk
about the FAT high word.

269
00:16:41.510 --> 00:16:45.405
The FAT high word values start at

270
00:16:45.405 --> 00:16:51.460
65,536 and they continue up,

271
00:16:51.460 --> 00:16:55.460
a power of two for
each column value.

272
00:16:58.860 --> 00:17:01.210
If you had a high word,

273
00:17:01.210 --> 00:17:07.960
you'd be reading it as
a string of four bytes.

274
00:17:07.960 --> 00:17:13.250
So it'd be a 32-bit value
it'd be four bytes long.

275
00:17:13.320 --> 00:17:17.755
We would have to
account for 32 bits.

276
00:17:17.755 --> 00:17:21.280
We'd start with one, with two,

277
00:17:21.280 --> 00:17:23.905
doubling all the
way as we go out,

278
00:17:23.905 --> 00:17:26.710
to get to 32 bits.

279
00:17:26.710 --> 00:17:29.990
We need place values for 32 bits.

280
00:17:32.220 --> 00:17:35.485
Then we would split

281
00:17:35.485 --> 00:17:40.045
our bytes to the low
and the high word.

282
00:17:40.045 --> 00:17:44.210
We'd first convert the low word.

283
00:17:45.420 --> 00:17:48.805
To convert from hex to binary,

284
00:17:48.805 --> 00:17:52.915
we're going to convert
each nibble at a time.

285
00:17:52.915 --> 00:17:54.940
When we convert nibbles,

286
00:17:54.940 --> 00:17:58.375
remember back in the path
when we went over that,

287
00:17:58.375 --> 00:18:02.950
we used the values one through
eight for each nibble.

288
00:18:02.950 --> 00:18:06.295
Because a nibble
only has four bits.

289
00:18:06.295 --> 00:18:10.480
Four bits would be 1, 2, 4, 8.

290
00:18:10.480 --> 00:18:13.089
Those would be our 4-bit values.

291
00:18:13.089 --> 00:18:17.935
We look at the one. We
would start with eight.

292
00:18:17.935 --> 00:18:20.155
Eight can't go into one,

293
00:18:20.155 --> 00:18:22.705
four does not go into one,

294
00:18:22.705 --> 00:18:24.985
two does not go into one,

295
00:18:24.985 --> 00:18:26.665
one goes into one.

296
00:18:26.665 --> 00:18:28.270
We put a one.

297
00:18:28.270 --> 00:18:30.370
We'd have a one in
the ones column,

298
00:18:30.370 --> 00:18:31.690
a zero in the two,

299
00:18:31.690 --> 00:18:34.300
a zero in the four, and
a zero in the eight.

300
00:18:34.300 --> 00:18:38.545
Then we would move to the
seven. We do the same thing.

301
00:18:38.545 --> 00:18:40.240
We'd have column values of 1,

302
00:18:40.240 --> 00:18:41.845
2, 4, and 8.

303
00:18:41.845 --> 00:18:43.765
Because we're converting a nibble

304
00:18:43.765 --> 00:18:46.370
which is four bits long.

305
00:18:46.680 --> 00:18:48.820
Eight won't go into

306
00:18:48.820 --> 00:18:51.910
seven so we put a zero
in the eights column.

307
00:18:51.910 --> 00:18:54.010
Four will go into seven,

308
00:18:54.010 --> 00:18:57.550
so we put a one, and
we subtract 4 from 7,

309
00:18:57.550 --> 00:19:00.260
which would give us
a remainder of 3.

310
00:19:00.300 --> 00:19:03.940
Two will go into three one time,

311
00:19:03.940 --> 00:19:06.940
and one will go
into one one time.

312
00:19:06.940 --> 00:19:10.300
That is how we would
convert the byte.

313
00:19:10.300 --> 00:19:15.580
We would do the
same thing for 2E.

314
00:19:15.580 --> 00:19:17.635
We would convert the E,

315
00:19:17.635 --> 00:19:21.625
which in hexadecimal E is 14.

316
00:19:21.625 --> 00:19:24.760
We would start with our eights.

317
00:19:24.760 --> 00:19:28.945
Eight will go into 14 one time,

318
00:19:28.945 --> 00:19:31.550
so we would put a
one in the eight.

319
00:19:31.680 --> 00:19:35.260
That will give us a
remainder of six.

320
00:19:35.260 --> 00:19:38.125
Four will go into six one time.

321
00:19:38.125 --> 00:19:40.540
It will give us a
remainder of two.

322
00:19:40.540 --> 00:19:42.910
Two will go into two once.

323
00:19:42.910 --> 00:19:47.455
We put a one in that column
and then we would have zero.

324
00:19:47.455 --> 00:19:50.875
Zero will not go into
one so we would put

325
00:19:50.875 --> 00:19:54.800
a zero in the ones column.

326
00:19:56.490 --> 00:20:00.080
Then we continue with two.

327
00:20:02.610 --> 00:20:04.675
We'd start with eight,

328
00:20:04.675 --> 00:20:08.635
eight will not go into
two so we'd put a zero.

329
00:20:08.635 --> 00:20:13.030
Four will not go into
two. We'd put a zero.

330
00:20:13.030 --> 00:20:15.970
Two will go into
two so we would put

331
00:20:15.970 --> 00:20:22.405
a one and that would give
us a remainder of zero.

332
00:20:22.405 --> 00:20:24.520
One will not go into

333
00:20:24.520 --> 00:20:27.980
zero so we would put a
zero in the ones column.

334
00:20:28.170 --> 00:20:32.900
That would bring us
to our high word.

335
00:20:33.690 --> 00:20:40.145
Our high word value when
we split the byte is nine.

336
00:20:40.145 --> 00:20:44.330
Then we have all zeros for
the rest of our value.

337
00:20:44.330 --> 00:20:46.615
We'd start with the nine.

338
00:20:46.615 --> 00:20:49.195
Eight will go into nine once.

339
00:20:49.195 --> 00:20:51.100
A remainder of one.

340
00:20:51.100 --> 00:20:54.205
Four will not go into
one, so we put a zero.

341
00:20:54.205 --> 00:20:57.580
Two will not go into one so
we put a zero in that column.

342
00:20:57.580 --> 00:20:59.215
One will go into one,

343
00:20:59.215 --> 00:21:00.910
we put a one in that column.

344
00:21:00.910 --> 00:21:03.145
Now the rest of our
values is zero,

345
00:21:03.145 --> 00:21:05.140
so would just put zeros
in the remainder of

346
00:21:05.140 --> 00:21:09.575
the columns to fill
in the 32 bits.

347
00:21:09.575 --> 00:21:11.830
Now we go back and add

348
00:21:11.830 --> 00:21:15.890
the actual column
values for our bits.

349
00:21:15.980 --> 00:21:19.340
We would start with 524,288.

350
00:21:25.680 --> 00:21:30.205
That's where we have our
1, so we have that number.

351
00:21:30.205 --> 00:21:32.200
We'd write that down,

352
00:21:32.200 --> 00:21:34.930
we'd go to the next column
there where we have a 1,

353
00:21:34.930 --> 00:21:40.660
and that would be column 65,536.

354
00:21:40.660 --> 00:21:43.480
We would write that number down.

355
00:21:43.480 --> 00:21:46.570
Our next column
value, we have a 1,

356
00:21:46.570 --> 00:21:52.300
we have 8,192, we'd
write that number down.

357
00:21:52.300 --> 00:21:55.210
The next number
where we have a 1 in

358
00:21:55.210 --> 00:21:58.195
our column value is 2,048,

359
00:21:58.195 --> 00:22:00.145
I'm going to write that down.

360
00:22:00.145 --> 00:22:02.080
The next column
where we have a 1 in

361
00:22:02.080 --> 00:22:05.845
our column values is 1,024,

362
00:22:05.845 --> 00:22:08.005
and we will write that down.

363
00:22:08.005 --> 00:22:10.180
The next number
where we have a 1 in

364
00:22:10.180 --> 00:22:13.495
our column values is
512, we write that down.

365
00:22:13.495 --> 00:22:16.315
The next number would be 64,

366
00:22:16.315 --> 00:22:20.395
32, 16, and 1.

367
00:22:20.395 --> 00:22:21.760
We would write all these numbers

368
00:22:21.760 --> 00:22:24.190
down and then add them together.

369
00:22:24.190 --> 00:22:29.785
That gives us a total of 601,713.

370
00:22:29.785 --> 00:22:32.860
The starting cluster
for this file

371
00:22:32.860 --> 00:22:38.390
would be cluster 601,713.

372
00:22:38.490 --> 00:22:41.980
Here we're taking another
look at our high word.

373
00:22:41.980 --> 00:22:44.020
There's our high word value, 9,

374
00:22:44.020 --> 00:22:46.330
and there's our low
word value of 71 2E.

375
00:22:46.330 --> 00:22:49.825
We convert them to little-Endian,

376
00:22:49.825 --> 00:22:52.450
we break them apart,

377
00:22:52.450 --> 00:22:57.200
we'd get our values just like
we did in the last slide,

378
00:22:57.210 --> 00:22:59.995
and we can add those
values together,

379
00:22:59.995 --> 00:23:05.380
and we come up with our 601,714.

380
00:23:05.380 --> 00:23:09.520
Now, your tools are going
to do this for you,

381
00:23:09.520 --> 00:23:13.420
and you can use the
Window's calculator

382
00:23:13.420 --> 00:23:17.665
to convert these bytes also.

383
00:23:17.665 --> 00:23:20.470
You'd be converting
them as a D word,

384
00:23:20.470 --> 00:23:23.990
a double word, a 32-bit value.

385
00:23:24.150 --> 00:23:29.350
The FAT file modification
date and time,

386
00:23:29.350 --> 00:23:31.615
it is read little-Endian.

387
00:23:31.615 --> 00:23:33.355
If you want to
manually decode it,

388
00:23:33.355 --> 00:23:35.260
you would do it the
same as you did

389
00:23:35.260 --> 00:23:37.900
for the file creation
date and time,

390
00:23:37.900 --> 00:23:39.865
just convert it the same way.

391
00:23:39.865 --> 00:23:42.460
Again, your tools will do

392
00:23:42.460 --> 00:23:44.830
this for you and
you'll see that when

393
00:23:44.830 --> 00:23:46.900
we do the walk-through with

394
00:23:46.900 --> 00:23:49.960
Active Disk Editor at
the end of the module.

395
00:23:49.960 --> 00:23:54.940
That file size is read
little-Endian, it's four bytes,

396
00:23:54.940 --> 00:24:00.085
32-bit value, and it's
the file size in bytes,

397
00:24:00.085 --> 00:24:03.590
is the size of the file in bytes.

398
00:24:05.280 --> 00:24:11.540
The long file name
directory entry.

399
00:24:12.540 --> 00:24:17.110
We're looking at a long
file name directory entry.

400
00:24:17.110 --> 00:24:19.840
We're looking at a file
directory set right here,

401
00:24:19.840 --> 00:24:21.580
but we're going to focus on

402
00:24:21.580 --> 00:24:22.990
the long file name because we've

403
00:24:22.990 --> 00:24:25.225
already talked about
the short file name.

404
00:24:25.225 --> 00:24:28.630
But you can see the
DOS alias in slide,

405
00:24:28.630 --> 00:24:32.960
and now we can see the
long file name entries.

406
00:24:34.350 --> 00:24:36.490
The first byte of

407
00:24:36.490 --> 00:24:41.770
a long file name entry is
called the sequence byte.

408
00:24:41.770 --> 00:24:47.545
Now, the right nibble
is the sequence order.

409
00:24:47.545 --> 00:24:48.940
The right nibble of that byte,

410
00:24:48.940 --> 00:24:51.100
you can see we have 1, 2, 3,

411
00:24:51.100 --> 00:24:56.950
and 4, that's the order that
this file name is read.

412
00:24:56.950 --> 00:24:59.350
The left nibble is going to

413
00:24:59.350 --> 00:25:02.200
indicate the last
entry in the set.

414
00:25:02.200 --> 00:25:05.725
You can see we have a 01, 02,

415
00:25:05.725 --> 00:25:07.990
a 03, and look,

416
00:25:07.990 --> 00:25:09.475
we have a 44.

417
00:25:09.475 --> 00:25:15.505
That 4 indicates the last
entry in the directory set.

418
00:25:15.505 --> 00:25:19.000
It could have been 43 or 42,

419
00:25:19.000 --> 00:25:21.745
depending on the
length of the file,

420
00:25:21.745 --> 00:25:23.725
but the first nibble,

421
00:25:23.725 --> 00:25:27.550
the right nibble
represents the order,

422
00:25:27.550 --> 00:25:32.270
the left nibble indicates
the last entry.

423
00:25:32.490 --> 00:25:36.535
We've talked about
the status byte

424
00:25:36.535 --> 00:25:39.145
when we're talking about
the long file name.

425
00:25:39.145 --> 00:25:41.920
The rest of the long
file name pretty

426
00:25:41.920 --> 00:25:46.040
much only gives us
the name of the file.

427
00:25:49.560 --> 00:25:54.505
There is a long file
name flag at offset 0B,

428
00:25:54.505 --> 00:25:57.130
you'll see a value of 0F.

429
00:25:57.130 --> 00:26:02.080
When you see that value
of 0F at offset 0B,

430
00:26:02.080 --> 00:26:06.115
that tells you you're
looking at a long file name.

431
00:26:06.115 --> 00:26:11.410
We can also see the
reserved byte is 00.

432
00:26:11.410 --> 00:26:13.540
We saw a few slides back that,

433
00:26:13.540 --> 00:26:17.140
that also indicates
a long file name.

434
00:26:17.140 --> 00:26:19.510
That is how you can tell you're

435
00:26:19.510 --> 00:26:22.100
looking at a long
file name entry.

436
00:26:22.100 --> 00:26:25.960
Now we're going to do a
walk-through and take

437
00:26:25.960 --> 00:26:32.525
a look with Active Disk
Editor at our root directory.

438
00:26:32.525 --> 00:26:36.170
Please attach your MBR_VHD.

439
00:26:37.440 --> 00:26:39.625
Once you attach it,

440
00:26:39.625 --> 00:26:43.105
note the disk number
of your attached VHD,

441
00:26:43.105 --> 00:26:44.470
so when we go to look for it,

442
00:26:44.470 --> 00:26:46.840
we know what number
we're looking for.

443
00:26:46.840 --> 00:26:50.950
I also want you to open
Active Disk Editor.

444
00:26:50.950 --> 00:26:52.600
To start our walk-through,

445
00:26:52.600 --> 00:26:56.570
the first thing we need
to do is attach our VHD.

446
00:26:57.090 --> 00:27:02.665
Go to Actions, attach VHD,

447
00:27:02.665 --> 00:27:07.615
navigate out to where
your VHD is saved,

448
00:27:07.615 --> 00:27:12.770
and click "Open" to
attach your VHD.

449
00:27:14.700 --> 00:27:17.350
Once your VHD is attached,

450
00:27:17.350 --> 00:27:19.700
it should look like mine.

451
00:27:21.540 --> 00:27:24.040
You should have an
extended partition on

452
00:27:24.040 --> 00:27:26.870
there and you should
have six volumes.

453
00:27:28.230 --> 00:27:32.630
Now, we're going to open
up Active Disk Editor.

454
00:27:37.290 --> 00:27:41.425
Once Active Disk Editor opens,

455
00:27:41.425 --> 00:27:44.515
we're going to
select "Open Disk",

456
00:27:44.515 --> 00:27:47.245
now we want to look
at our volumes,

457
00:27:47.245 --> 00:27:49.970
so we're going to select volumes.

458
00:27:50.520 --> 00:27:54.355
Because we're looking
at a logical volume.

459
00:27:54.355 --> 00:28:01.460
We're going to choose
our FAT 32 volume S,

460
00:28:03.390 --> 00:28:06.355
I'm going to select it,

461
00:28:06.355 --> 00:28:09.680
and we're going to click "Open".

462
00:28:10.980 --> 00:28:16.730
We're immediately taken to
the volume boot record.

463
00:28:16.730 --> 00:28:20.279
We covered the volume boot
record in our last module.

464
00:28:20.279 --> 00:28:23.190
But there are some things
you need to look at in

465
00:28:23.190 --> 00:28:27.020
a volume boot record
all the time.

466
00:28:29.160 --> 00:28:34.300
What we want to see
is bytes per sector,

467
00:28:34.300 --> 00:28:37.300
and make a notice
sectors per cluster.

468
00:28:37.300 --> 00:28:41.095
We can see we have four
sectors per cluster.

469
00:28:41.095 --> 00:28:45.385
Our previous walk through
we had a FAT volume with

470
00:28:45.385 --> 00:28:50.365
two sectors per cluster.

471
00:28:50.365 --> 00:28:54.370
There can be variations
in how many sectors per

472
00:28:54.370 --> 00:28:58.975
cluster you're looking at
especially with a FAT volume.

473
00:28:58.975 --> 00:29:01.120
You want to check
that out and make

474
00:29:01.120 --> 00:29:05.830
sure you know bytes per sector
and sectors per cluster.

475
00:29:05.830 --> 00:29:08.680
Now, we're looking for
the root directory and

476
00:29:08.680 --> 00:29:12.175
we can see the root cluster
is still cluster 2.

477
00:29:12.175 --> 00:29:15.775
Cluster 2 is where we want to go.

478
00:29:15.775 --> 00:29:18.700
We go ahead and click
on "Cluster 2",

479
00:29:18.700 --> 00:29:20.455
we'll use our shortcut here,

480
00:29:20.455 --> 00:29:23.005
where it says root cluster
here on the left-hand side,

481
00:29:23.005 --> 00:29:25.890
we'll select cluster
2 and then take

482
00:29:25.890 --> 00:29:30.200
in to our FAT 32 root directory.

483
00:29:30.200 --> 00:29:37.310
We can see the first entry
is our volume label.

484
00:29:38.610 --> 00:29:43.550
Right-click and set
template position.

485
00:29:44.610 --> 00:29:47.815
We can see we have the filename,

486
00:29:47.815 --> 00:29:50.335
our volume label
has no extension.

487
00:29:50.335 --> 00:29:52.720
You're going to see these dots in

488
00:29:52.720 --> 00:29:56.870
ASCII represented
as hexadecimal 20.

489
00:29:58.590 --> 00:30:02.180
We do have an attribute byte.

490
00:30:03.420 --> 00:30:06.775
We look at our attribute byte,

491
00:30:06.775 --> 00:30:09.789
we're going to expand attribute

492
00:30:09.789 --> 00:30:12.550
and we can see we're looking at

493
00:30:12.550 --> 00:30:14.710
the volume attribute is

494
00:30:14.710 --> 00:30:19.190
set that indicates to us
that this is a volume name.

495
00:30:21.210 --> 00:30:23.530
We do see one date and

496
00:30:23.530 --> 00:30:31.700
time which is a
modified date and time,

497
00:30:31.830 --> 00:30:34.465
and it is 82,

498
00:30:34.465 --> 00:30:39.595
2020 at 3:09 AM.

499
00:30:39.595 --> 00:30:41.920
Now, remember these
are local times,

500
00:30:41.920 --> 00:30:45.400
which means whatever time
it is on the computer,

501
00:30:45.400 --> 00:30:48.595
it's going to be the same time

502
00:30:48.595 --> 00:30:52.750
that's stored in our
directory entries.

503
00:30:52.750 --> 00:30:55.210
It is possible that
somebody can set

504
00:30:55.210 --> 00:30:57.250
their computer to a time
zone that they're not

505
00:30:57.250 --> 00:30:59.050
in or maybe they

506
00:30:59.050 --> 00:31:02.155
got a new computer and
never reset the time zone.

507
00:31:02.155 --> 00:31:06.670
But this time recorded in
the root directory in FAT,

508
00:31:06.670 --> 00:31:08.650
is going to be the time

509
00:31:08.650 --> 00:31:11.300
from the system
it's operating on.

510
00:31:13.560 --> 00:31:18.640
Now let's look down you see
we have a lot of entries.

511
00:31:18.640 --> 00:31:24.620
We're going to take a
look at the entry, SHORT.

512
00:31:24.620 --> 00:31:30.745
TXT. This is a short
filename entry.

513
00:31:30.745 --> 00:31:34.435
This file is named SHORT TXT,

514
00:31:34.435 --> 00:31:37.675
because you can see
in the entry above,

515
00:31:37.675 --> 00:31:42.460
it's not related to

516
00:31:42.460 --> 00:31:44.920
the century because it
starts with a hex E5,

517
00:31:44.920 --> 00:31:48.595
which we're going to talk
about in future module,

518
00:31:48.595 --> 00:31:51.850
but you can also see that
this is not a DOS alias.

519
00:31:51.850 --> 00:31:53.465
There's no tilde here.

520
00:31:53.465 --> 00:31:54.975
It's just the filename,

521
00:31:54.975 --> 00:31:57.330
a space, and then the TXT.

522
00:31:57.330 --> 00:32:00.970
If this were a DOS alias,
that'll be utility.

523
00:32:04.700 --> 00:32:09.360
We'll see that when we look
at our next directory entry.

524
00:32:09.360 --> 00:32:13.710
What we're going to do
is highlight the 53,

525
00:32:13.710 --> 00:32:17.440
right-click, and "Set
template position".

526
00:32:18.140 --> 00:32:22.920
Now we can look at our
short filename entry.

527
00:32:22.920 --> 00:32:25.020
What's nice about this tool is it

528
00:32:25.020 --> 00:32:26.970
does highlight it all for us,

529
00:32:26.970 --> 00:32:30.675
and it does translate
all the data for us.

530
00:32:30.675 --> 00:32:32.520
We looked at how
we would manually

531
00:32:32.520 --> 00:32:34.590
translate the creation date and

532
00:32:34.590 --> 00:32:40.485
time in the high
word, if we had one.

533
00:32:40.485 --> 00:32:44.970
But the entry is going to
start with the file name,

534
00:32:44.970 --> 00:32:48.280
followed by the file extension.

535
00:32:48.440 --> 00:32:52.810
Then we have our attribute byte,

536
00:32:52.820 --> 00:32:56.980
and we have a hexadecimal 2,0.

537
00:32:57.830 --> 00:33:00.795
We can go ahead in

538
00:33:00.795 --> 00:33:07.395
our template and look
at our attribute.

539
00:33:07.395 --> 00:33:12.060
We can see this is
an archived file.

540
00:33:12.060 --> 00:33:13.515
None of the other bytes are set,

541
00:33:13.515 --> 00:33:15.640
just the archive bit.

542
00:33:19.750 --> 00:33:22.505
Then we have that reserved byte.

543
00:33:22.505 --> 00:33:24.290
We said that reserved byte will

544
00:33:24.290 --> 00:33:26.670
indicate if it's a short filename

545
00:33:26.670 --> 00:33:28.695
or a long filename entry.

546
00:33:28.695 --> 00:33:34.270
Hexadecimal 1,0 indicates
short filename entry.

547
00:33:34.700 --> 00:33:42.030
Now we have our
millisecond creation time.

548
00:33:42.030 --> 00:33:44.880
This is a refinement of

549
00:33:44.880 --> 00:33:49.140
10 milliseconds for the
creation date and time only.

550
00:33:49.140 --> 00:33:54.460
This only relates to creation
time, not modified time.

551
00:33:55.730 --> 00:34:01.690
1F would be a decimal 31.

552
00:34:01.970 --> 00:34:06.105
Next, we have our
creation date and time.

553
00:34:06.105 --> 00:34:08.790
We looked at this in our
slides and we learned how

554
00:34:08.790 --> 00:34:11.565
to manually interpret that,

555
00:34:11.565 --> 00:34:14.160
but you can see here that

556
00:34:14.160 --> 00:34:17.160
the tool does
interpret it for us.

557
00:34:17.160 --> 00:34:19.260
If we wanted to validate that,

558
00:34:19.260 --> 00:34:23.230
we could break that out and
interpret it ourselves.

559
00:34:23.450 --> 00:34:25.935
Now, the millisecond time,

560
00:34:25.935 --> 00:34:28.365
if we were going to be adding it,

561
00:34:28.365 --> 00:34:31.900
you would add it on
the end of the time.

562
00:34:34.670 --> 00:34:38.505
You'd put a colon after the 50,

563
00:34:38.505 --> 00:34:43.890
and add in the millisecond
time, which was 31.

564
00:34:43.890 --> 00:34:49.150
So it'd be 5:50, 31 milliseconds.

565
00:34:51.380 --> 00:34:55.185
Now we have our last access date,

566
00:34:55.185 --> 00:34:59.265
and again we only have a date
with last access, no time.

567
00:34:59.265 --> 00:35:05.265
The next two bytes are
going to be the high word.

568
00:35:05.265 --> 00:35:09.180
We'd only have a high
word if we needed

569
00:35:09.180 --> 00:35:11.550
more than two bytes

570
00:35:11.550 --> 00:35:13.950
to address the starting
cluster of this file.

571
00:35:13.950 --> 00:35:16.120
In this case, we don't.

572
00:35:17.480 --> 00:35:21.460
Next, we have our
modified date and time.

573
00:35:22.820 --> 00:35:27.585
Now we have our cluster lowered,

574
00:35:27.585 --> 00:35:30.090
and because we did
not have a high word,

575
00:35:30.090 --> 00:35:33.120
this is the actual starting
cluster of our file.

576
00:35:33.120 --> 00:35:36.460
Our files are going to
start in cluster 10.

577
00:35:36.830 --> 00:35:39.495
Now we have the file size.

578
00:35:39.495 --> 00:35:42.600
These values all
read little-endian,

579
00:35:42.600 --> 00:35:47.505
so 00, 0A, we know
that A would be 10.

580
00:35:47.505 --> 00:35:51.850
A hexadecimal A would
be a decimal 10.

581
00:35:51.950 --> 00:35:54.075
Again, this would be read

582
00:35:54.075 --> 00:35:57.130
little-endian from left to right.

583
00:35:58.760 --> 00:36:04.545
Our file size would be 127 bytes.

584
00:36:04.545 --> 00:36:08.745
This value is giving us
our file size in bytes.

585
00:36:08.745 --> 00:36:11.070
That's how we read and interpret

586
00:36:11.070 --> 00:36:14.350
this short filename
directory entry.

587
00:36:15.770 --> 00:36:19.335
Now, a long filename
directory entry.

588
00:36:19.335 --> 00:36:25.960
We're going to choose
this new tilde 1TXT.

589
00:36:26.440 --> 00:36:28.640
I can already tell this as

590
00:36:28.640 --> 00:36:31.100
the DOS alias by the
tilde and ASCII.

591
00:36:31.100 --> 00:36:33.020
The tilde is this little
squiggly sign right

592
00:36:33.020 --> 00:36:36.100
here, that's the tilde.

593
00:36:37.520 --> 00:36:41.340
Highlight the beginning
of the file entry,

594
00:36:41.340 --> 00:36:45.910
right-click, "Set
template position".

595
00:36:48.650 --> 00:36:53.020
This is, again, a
short filename entry.

596
00:36:54.080 --> 00:36:58.660
If we look above it,
we do see the 0F.

597
00:37:01.340 --> 00:37:03.780
The tilde tells us
that we're going to

598
00:37:03.780 --> 00:37:05.430
have long filename entries above

599
00:37:05.430 --> 00:37:09.640
this short filename
because it is a DOS alias.

600
00:37:10.010 --> 00:37:12.540
It would be read exactly the same

601
00:37:12.540 --> 00:37:16.690
way as any other
short filename entry.

602
00:37:17.000 --> 00:37:19.380
We go above this, we see

603
00:37:19.380 --> 00:37:22.300
the status byte for
the long filename.

604
00:37:22.910 --> 00:37:26.265
The status bytes is 0,1.

605
00:37:26.265 --> 00:37:32.685
This tells us the right
nibble is the sequence,

606
00:37:32.685 --> 00:37:34.710
the left nibble will indicate

607
00:37:34.710 --> 00:37:40.750
the last directory entry in
the set for that filename.

608
00:37:41.390 --> 00:37:46.185
We see 0,1, so this
is the first entry,

609
00:37:46.185 --> 00:37:48.240
but we're going to have
another one above it.

610
00:37:48.240 --> 00:37:51.150
We look above it,
we do see a 4,2.

611
00:37:51.150 --> 00:37:54.465
Two indicates it's the
second long filename entry,

612
00:37:54.465 --> 00:37:56.865
and the four, the left nibble

613
00:37:56.865 --> 00:38:00.700
indicates it's the last one
in this directory entry set.

614
00:38:01.680 --> 00:38:04.555
We see we have the status byte.

615
00:38:04.555 --> 00:38:05.935
Next to status byte,

616
00:38:05.935 --> 00:38:10.660
we have the first five
characters of the filename.

617
00:38:10.660 --> 00:38:14.080
In this case, it
would be new space

618
00:38:14.080 --> 00:38:18.110
t. Space is count as a character.

619
00:38:18.270 --> 00:38:20.290
We can see we have

620
00:38:20.290 --> 00:38:25.165
our attribute byte 0F
indicates a long filename.

621
00:38:25.165 --> 00:38:27.999
We also have our reserved,

622
00:38:27.999 --> 00:38:33.620
which is 00 which also
indicates long filename.

623
00:38:33.620 --> 00:38:36.965
There is a checksum
value in here.

624
00:38:36.965 --> 00:38:39.590
That's for error checking.

625
00:38:39.600 --> 00:38:44.720
Then we have characters 6
through 11 of the filename,

626
00:38:46.950 --> 00:38:50.560
and then after that,

627
00:38:50.560 --> 00:38:52.270
we're going to have
these two bytes that

628
00:38:52.270 --> 00:38:54.710
are always going to be 00,

629
00:38:54.900 --> 00:39:01.730
and then we have characters
12 and 13 of the filename.

630
00:39:03.510 --> 00:39:10.510
It says new texts docu is
what we've got so far.

631
00:39:10.510 --> 00:39:14.020
We go up to the next long
filename directory entry.

632
00:39:14.020 --> 00:39:18.145
Remember, all these
entries are 32 bytes,

633
00:39:18.145 --> 00:39:20.470
two lines of 16 in length.

634
00:39:20.470 --> 00:39:22.375
They're 32 byte entries.

635
00:39:22.375 --> 00:39:27.040
Right-click, set
template position.

636
00:39:27.040 --> 00:39:32.540
It's actually showing us the
entire directory set here,

637
00:39:33.030 --> 00:39:36.160
but we're going to read this one.

638
00:39:36.160 --> 00:39:39.520
I'm going to right-click,
set template position,

639
00:39:39.520 --> 00:39:45.085
and we're going to click
in the filename entry.

640
00:39:45.085 --> 00:39:47.800
We can see our status byte is 42.

641
00:39:47.800 --> 00:39:52.300
Four indicates the last
directory entry in the set,

642
00:39:52.300 --> 00:39:54.250
so we know this is the last entry

643
00:39:54.250 --> 00:39:56.665
for this particular file,

644
00:39:56.665 --> 00:40:00.160
and two tells us
it's the second one,

645
00:40:00.160 --> 00:40:04.945
so this file has two
long filename entries.

646
00:40:04.945 --> 00:40:09.219
We can see we have
remaining characters

647
00:40:09.219 --> 00:40:13.659
here of the long filename,

648
00:40:14.220 --> 00:40:18.235
the next five characters
of the long filename.

649
00:40:18.235 --> 00:40:20.980
In this particular case,
they are the last ones.

650
00:40:20.980 --> 00:40:25.880
We also have our attribute byte

651
00:40:25.880 --> 00:40:30.430
which for a long filename
will always be 0f.

652
00:40:31.230 --> 00:40:36.610
Then we have the reserved
byte which is 00,

653
00:40:36.610 --> 00:40:39.500
indicating a long filename.

654
00:40:41.640 --> 00:40:46.310
Now, we have a
checksum byte again.

655
00:40:47.070 --> 00:40:54.460
In here, we would have the
characters of the extension.

656
00:40:54.460 --> 00:40:57.010
The next character is and
the filename 6 through 11.

657
00:40:57.010 --> 00:41:01.190
In this case, it is our
file extension TXT.

658
00:41:04.140 --> 00:41:07.790
Then these bytes
would always be 00,

659
00:41:07.980 --> 00:41:10.270
and this would be

660
00:41:10.270 --> 00:41:14.485
the next two characters
of the filename,

661
00:41:14.485 --> 00:41:17.260
but it is FF, FF, FF,

662
00:41:17.260 --> 00:41:19.690
FF because our filename

663
00:41:19.690 --> 00:41:21.805
does not have any
further characters.

664
00:41:21.805 --> 00:41:24.790
Once you come to the last
character in the filename,

665
00:41:24.790 --> 00:41:28.700
they will pad the rest
of the entry with FF,

666
00:41:30.930 --> 00:41:33.010
and that is how we read

667
00:41:33.010 --> 00:41:36.350
the long filename
directory entries.

668
00:41:38.760 --> 00:41:44.695
Now, going back to
the short filename,

669
00:41:44.695 --> 00:41:48.400
it says our starting cluster,

670
00:41:48.400 --> 00:41:53.000
there's no high word so our
lowered cluster says nine.

671
00:41:53.040 --> 00:41:56.875
Let's just take a look
and navigate there,

672
00:41:56.875 --> 00:41:58.600
so we're going to go to

673
00:41:58.600 --> 00:42:00.940
sector and we're going
to write this in

674
00:42:00.940 --> 00:42:05.620
hex because this tool
likes to navigate in hex.

675
00:42:05.620 --> 00:42:13.160
We're going to say 0x to
indicate we're in hex 09.

676
00:42:13.530 --> 00:42:16.600
We're going to write 0x09,

677
00:42:16.600 --> 00:42:18.475
we're going to cluster 09.

678
00:42:18.475 --> 00:42:20.215
I'm going to say okay,

679
00:42:20.215 --> 00:42:21.625
and we get out there.

680
00:42:21.625 --> 00:42:25.270
We can see there is a
small text document

681
00:42:25.270 --> 00:42:29.770
here and we can see what it says.

682
00:42:29.770 --> 00:42:32.125
This is a new file document,

683
00:42:32.125 --> 00:42:34.450
and we're going to look at

684
00:42:34.450 --> 00:42:38.150
directory entries, which
is what we're doing.

685
00:42:39.300 --> 00:42:42.650
We verified that it's out there.

686
00:42:42.650 --> 00:42:46.180
We could verify the
size in bytes also.

687
00:42:50.490 --> 00:42:55.370
That is how we would read
our root directory entries.

688
00:42:57.420 --> 00:42:59.710
Your file system will stop

689
00:42:59.710 --> 00:43:01.945
reading when it comes to the 00.

690
00:43:01.945 --> 00:43:05.905
So if there was any
data written in here,

691
00:43:05.905 --> 00:43:10.880
it wouldn't see it
past the 00 entry.